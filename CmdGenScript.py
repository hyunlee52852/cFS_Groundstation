import sys
from MainWindow import Ui_MainWindow
from PyQt6 import QtWidgets, uic
from PyQt6.QtGui import QFont, QResizeEvent, QFontMetrics
from PyQt6.QtCore import Qt
import time

import serial.tools.list_ports

class MainWindow(QtWidgets.QMainWindow, Ui_MainWindow):
    def __init__(self, *args, obj=None, **kwargs):
        
        # Do not change, automatically generated by QT studio
        super(MainWindow, self).__init__(*args, **kwargs)
        self.setupUi(self)
        
        
        # Set window Title
        self.setWindowTitle("cFS Command Generator")
        
        # Set status Bar
        self.statusbar.showMessage("Idle...")
        
        # Flags
        self.updatingCmdHdrText = False
        self.updatingPayloadText = False
        
        # Setup the font for Command Editor
        self.CommandHeader_Font = QFont("Arial", 40)
        self.CommandHeader_Font.setBold(True)
        
        self.Payload_Font = QFont("Arial", 40)
        self.Payload_Font.setBold(True)
        
        # Allign the text to be in center
        self.textEdit_CommandHeader.setAlignment(Qt.AlignmentFlag.AlignVCenter)
        self.textEdit_Payload.setAlignment(Qt.AlignmentFlag.AlignVCenter)
        
        # Set the font
        self.textEdit_CommandHeader.setFont(self.CommandHeader_Font)
        self.textEdit_Payload.setFont(self.Payload_Font)
        
        # When the lineEdit is modified, call the modify_commandHeader_text function
        self.textEdit_CommandHeader.textChanged.connect(self.modify_commandHeader_text)
        self.textEdit_Payload.textChanged.connect(self.modify_Payload_text)
        
        # Connect the button to send command method
        self.pushButton_SendCommand.clicked.connect(self.send_command)
        
        # Refresh Ports
        self.refresh_ports()
        
        # Connect the Refresh Port button to refresh port
        self.pushButton_RefreshPorts.clicked.connect(self.refresh_ports)
        
        # Connect the port connect button
        self.pushButton_ConnectToPort.clicked.connect(self.connect_to_port)
        
        # Initial Port Status is Disconnected
        self.label_ConnectionStatus.setText("Disconnected")
        
        # Make Baud Rate Combobox
        baudrate_list = [4800, 9600, 19200, 38400, 57600, 115200, 230400, 460800, 921600] #List of common baud rates
        baudrate_str_list = [str(x) for x in baudrate_list]
        
        self.comboBox_selectBaud.clear()
        self.comboBox_selectBaud.addItems(baudrate_str_list)
        
        # Initialize CommandHeader & Payload list
        self.CmdHdr_hex_list = []
        self.Payload_hex_list = []
        
        # Initialize Serial
        self.CurrentSerialPort = serial.Serial()
        
        # Flag that indicates command is valid
        self.IsCommandValid = True
        
        self.pushButton_RefreshCommandList.clicked.connect(self.refresh_command_list)
        
        self.command_name = []
        self.command_list = []
        self.refresh_command_list()
        self.listWidget_CommandList.itemClicked.connect(self.load_from_selected_command)
    
    def load_from_selected_command(self, item):
        self.textEdit_CommandHeader.clear()
        self.textEdit_Payload.clear()
        
        index = self.listWidget_CommandList.indexFromItem(item).row()
        cmd_len = len(self.command_list[index])
        if cmd_len <= 16: # Only Command Header or less
            self.textEdit_CommandHeader.setText(self.command_list[index][:cmd_len])
        else: # Bigger than Command Header
            self.textEdit_CommandHeader.setText(self.command_list[index][:16])
            self.textEdit_Payload.setText(self.command_list[index][16:])
        
        self.modify_commandHeader_text()
        self.modify_Payload_text()
        
        self.statusBar().showMessage(f"Loaded Command : {self.command_name[index]}")
        
    def refresh_command_list(self):
        # Read the command list from a file
        try:
            with open("./commands/command_list.txt", "r") as file:
                command_list = file.readlines()
                self.command_list.clear()
                self.command_name.clear()
                for line in command_list:
                    self.command_name.append(line.split(":")[0])
                    self.command_list.append(line.split(":")[1].replace(" ", ""))
                self.listWidget_CommandList.clear()
                self.listWidget_CommandList.addItems(self.command_name)
        except Exception as e:
            print("Error reading command list:", e)
    
    def refresh_ports(self):
        ## Get lists of serial port
        ports = serial.tools.list_ports.comports()
        port_list = [f"{port.device}" for port in ports]
        print(port_list)
        self.print_on_statusbar(f"refreshed port list : {port_list}")
        self.comboBox_selectPort.clear()
        # Add the ports to ComboBox
        self.comboBox_selectPort.addItems(port_list)
        
    def connect_to_port(self):
        selected_port = self.comboBox_selectPort.currentText()
        selected_baud = int(self.comboBox_selectBaud.currentText())
        try:
            if self.CurrentSerialPort.is_open:
                self.CurrentSerialPort.close()
            self.CurrentSerialPort = serial.Serial(selected_port, selected_baud)
            print(self.CurrentSerialPort)
        except Exception as e:
            self.print_on_statusbar(f"Error during connection : {e}")
        self.label_ConnectionStatus.setText(f"Connected : {self.CurrentSerialPort.name}")
        self.print_on_statusbar(f"Connected to port {self.CurrentSerialPort.name}")
        
    def modify_commandHeader_text(self):
        if self.updatingCmdHdrText:
            return
        self.updatingCmdHdrText = True
        # Get the current plain text
        text = self.textEdit_CommandHeader.toPlainText().replace(" ", "")
        
        try:
            text = text[:16]
        except Exception as e:
            print("error", e)
            
        final_text = []
        color_list = ["blue", "blue", "green", "green", "purple", "purple", "grey", "brown"]
        self.CmdHdr_hex_list.clear()
        try:
            for i in range(int(len(text) / 2)):
                combined_text = text[(i* 2)] + text[(i * 2) + 1]
                try:
                    text_to_hex = hex(int(combined_text, base=16))
                    self.CmdHdr_hex_list.append(text_to_hex)
                    
                    if i == (len(text) / 2) - 1:
                        final_text.append(f'<span style="color:{color_list[i % 8]};">{combined_text}</span>')
                    else:
                        final_text.append(f'<span style="color:{color_list[i % 8]};">{combined_text}  </span>')

                except Exception as e:
                    print("Error! :", e)
        except Exception as e:
            print("Error editing test", e)
        
        # 길이가 홀수면 마지막 글자는 빨간색으로 칠하기
        if len(text) % 2 != 0:
            final_text.append(f'<span style="color:red;">{text[len(text) - 1]}</span>')
            self.IsCommandValid = False
        else:
            self.IsCommandValid = True
            
        html_content = ""
        
        # Combine and set the new HTML content
        for texts in final_text:
            html_content += texts    
        
        # Temporarily block signals to prevent recursive triggering
        self.textEdit_CommandHeader.blockSignals(True)

        # Set the HTML content back to the QTextEdit
        self.textEdit_CommandHeader.setHtml(html_content)

        # Move the cursor to the end of the text
        cursor = self.textEdit_CommandHeader.textCursor()
        cursor.movePosition(cursor.MoveOperation.End)
        self.textEdit_CommandHeader.setTextCursor(cursor)

        # Reconnect the signal
        self.textEdit_CommandHeader.blockSignals(False)
        
        self.updatingCmdHdrText = False
    
    def modify_Payload_text(self):
        if self.updatingPayloadText:
            return
        self.updatingPayloadText = True
        # Get the current plain text
        text = self.textEdit_Payload.toPlainText().replace(" ", "")
           
        final_text = []
        color_list = ["grey"]
        self.Payload_hex_list.clear()
        
        try:
            for i in range(int(len(text) / 2)):
                combined_text = text[(i* 2)] + text[(i * 2) + 1]
                try:
                    text_to_hex = hex(int(combined_text, base=16))
                    self.Payload_hex_list.append(text_to_hex)
                    
                    if i == (len(text) / 2) - 1:
                        final_text.append(f'<span style="color:{color_list[i % len(color_list)]};">{combined_text}</span>')
                    else:
                        final_text.append(f'<span style="color:{color_list[i % len(color_list)]};">{combined_text}  </span>')

                except Exception as e:
                    print("Error! :", e)
        except Exception as e:
            print("Error editing test", e)
        
        # 길이가 홀수면 마지막 글자는 빨간색으로 칠하기
        if len(text) % 2 != 0:
            final_text.append(f'<span style="color:red;">{text[len(text) - 1]}</span>')
            self.IsCommandValid = False
        else:
            self.IsCommandValid = True

        html_content = ""
        
        # Combine and set the new HTML content
        for texts in final_text:
            html_content += texts    
        
        # Temporarily block signals to prevent recursive triggering
        self.textEdit_Payload.blockSignals(True)

        # Set the HTML content back to the QTextEdit
        self.textEdit_Payload.setHtml(html_content)

        # Move the cursor to the end of the text
        cursor = self.textEdit_Payload.textCursor()
        cursor.movePosition(cursor.MoveOperation.End)
        self.textEdit_Payload.setTextCursor(cursor)

        # Reconnect the signal
        self.textEdit_Payload.blockSignals(False)
        
        self.updatingPayloadText = False
    
    def send_command(self):
        
        if self.IsCommandValid == False:
            self.print_on_statusbar("Command is Not Valid")
            return
        self.finalcommand = self.CmdHdr_hex_list + self.Payload_hex_list
        print(self.finalcommand)
        bytes_to_send = bytes([int(x,0) for x in self.finalcommand])
        
        # Print the byte array
        print(bytes_to_send.hex())
        if self.CurrentSerialPort.is_open:
            self.CurrentSerialPort.write(bytes_to_send)
            self.print_on_statusbar(f"Sent Command : {bytes_to_send.hex()}")
        else:
            self.print_on_statusbar("Port not opened!")
        
    def print_on_statusbar(self, str_to_print):
        current_time = time.strftime("%H:%M:%S")
        self.statusbar.showMessage(f"{current_time} : {str_to_print}")
    
    def resizeEvent(self, event: QResizeEvent) -> None:
        super().resizeEvent(event)
            
try:
    app = QtWidgets.QApplication(sys.argv)
    window = MainWindow()
    window.show()
    app.exec()
    
except Exception as e:
    print("Error!", e)
    app.quit()